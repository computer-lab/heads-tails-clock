{"version":3,"sources":["components/Credits/index.js","components/Lights/index.js","lib/volumetric-spotlight.js","components/LightGlobe/Light/VolumetricSpotlight.js","lib/index.js","components/LightGlobe/Light/Light.js","components/WebcamImageManager.js","components/LightGlobe/Light/EightSeriesHeadlightManager.js","components/LightGlobe/LightGlobe.js","index.js"],"names":["className","rel","href","target","intensity","position","attach","args","color","fog","distance","VolumetricSpotLightMaterial","vertexShader","join","fragmentShader","THREE","uniforms","attenuation","type","value","anglePower","spotPosition","lightColor","transparent","depthWrite","extend","VolumetricSpotlight","MyVolumetricSpotlight","React","forwardRef","props","ref","vs","useRef","spotlight","scene","useThree","angle","penumbra","useEffect","add","current","geometry","applyMatrix4","makeTranslation","parameters","height","makeRotationX","Math","PI","material","copy","useFrame","clock","targetPos","getWorldPosition","lookAt","x","setRef","useCallback","el","scale","set","uniforms-lightColor-value","uniforms-attenuation-value","uniforms-anglePower-value","sphericalCoordsToCartesian","radius","inclination","azimuth","sin","cos","z","latlngToSphericalCoords","lat","lng","abs","citiesWhereHeadlightsOn","Light","name","mesh","spotlightTarget","time","useState","isActive","isActiveRef","y","includes","corsProxy","WebcamImageManager","src","handleUpdateCubeMap","imgRef","newSrc","floor","Date","getTime","onload","inputWidth","naturalWidth","inputHeight","naturalHeight","inputImageAspectRatio","outputWidth","outputHeight","outputImage","document","createElement","width","getContext","drawImage","map","CubeTexture","needsUpdate","alt","style","display","crossOrigin","EightSeriesHeadlightManager","locations","nycCubeMap","setNycCubeMap","hkCubeMap","setHkCubeMap","nodes","useLoader","GLTFLoader","process","draco","refs","createRef","r","rotateY","meshObjects","i","envMap","key","visible","roughness","envMapIntensity","clearcoat","metalness","opacity","transmission","emissive","side","BackSide","LightGlobe","group","rotation","differenceInSeconds","startOfDay","cities","lights","coords","inc","azm","spotlightTargetPosition","loader","center","App","Credits","colorManagement","shadowMap","background","Lights","fallback","enablePan","zoomSpeed","factor","saturation","rootElement","getElementById","ReactDOM","render"],"mappings":"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","file":"static/js/main.f72c0f12.chunk.js","sourcesContent":["import React from \"react\";\n\nexport default () => {\n  return (\n    <div className=\"credits\">\n      <a\n        rel=\"noopener noreferrer\"\n        href=\"https://bortolamigallery.com/artist/madeline-hollander/bio/\"\n        target=\"_blank\"\n      >\n        Sunrise / Sunset\n      </a>\n      <br />\n      <a\n        rel=\"noopener noreferrer\"\n        href=\"https://bortolamigallery.com/artist/madeline-hollander/bio/\"\n        target=\"_blank\"\n      >\n        Madeline Hollander\n      </a>\n    </div>\n  );\n};\n","import React from \"react\";\n\nexport default () => {\n  return (\n    <group>\n      <ambientLight intensity={0.15} />\n      <mesh position={[-200, -10, 0]}>\n        <sphereBufferGeometry attach=\"geometry\" args={[4, 32, 32]} />\n        <meshBasicMaterial attach=\"material\" color=\"#FFFF99\" fog={false} />\n        <pointLight distance={6100} intensity={0.3} color={0xffffdd} />\n      </mesh>\n      <directionalLight\n        intensity={0.3}\n        position={[-1, 0, 0]}\n        color={0xffffdd}\n      />\n    </group>\n  );\n};\n","// adapted from https://github.com/jeromeetienne/threex.volumetricspotlight\nimport * as THREE from \"three\";\n\n/**\n * from http://stemkoski.blogspot.fr/2013/07/shaders-in-threejs-glow-and-halo.html\n * @return {[type]} [description]\n */\nconst VolumetricSpotLightMaterial = function() {\n  //\n  var vertexShader = [\n    \"varying vec3 vNormal;\",\n    \"varying vec3 vWorldPosition;\",\n\n    \"void main(){\",\n    \"// compute intensity\",\n    \"vNormal\t\t= normalize( normalMatrix * normal );\",\n\n    \"vec4 worldPosition\t= modelMatrix * vec4( position, 1.0 );\",\n    \"vWorldPosition\t\t= worldPosition.xyz;\",\n\n    \"// set gl_Position\",\n    \"gl_Position\t= projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\");\n  var fragmentShader = [\n    \"varying vec3\t\tvNormal;\",\n    \"varying vec3\t\tvWorldPosition;\",\n\n    \"uniform vec3\t\tlightColor;\",\n\n    \"uniform vec3\t\tspotPosition;\",\n\n    \"uniform float\t\tattenuation;\",\n    \"uniform float\t\tanglePower;\",\n\n    \"void main(){\",\n    \"float intensity;\",\n\n    //////////////////////////////////////////////////////////\n    // distance attenuation\t\t\t\t\t//\n    //////////////////////////////////////////////////////////\n    \"intensity\t= distance(vWorldPosition, spotPosition)/attenuation;\",\n    \"intensity\t= 1.0 - clamp(intensity, 0.0, 1.0);\",\n\n    //////////////////////////////////////////////////////////\n    // intensity on angle\t\t\t\t\t//\n    //////////////////////////////////////////////////////////\n    \"vec3 normal\t= vec3(vNormal.x, vNormal.y, abs(vNormal.z));\",\n    \"float angleIntensity\t= pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );\",\n    \"intensity\t= intensity * angleIntensity;\",\n    // 'gl_FragColor\t= vec4( lightColor, intensity );',\n\n    //////////////////////////////////////////////////////////\n    // final color\t\t\t\t\t\t//\n    //////////////////////////////////////////////////////////\n\n    // set the final color\n    \"gl_FragColor\t= vec4( lightColor, intensity);\",\n    \"}\"\n  ].join(\"\\n\");\n\n  // create custom material from the shader code above\n  //   that is within specially labeled script tags\n  var material = new THREE.ShaderMaterial({\n    uniforms: {\n      attenuation: {\n        type: \"f\",\n        value: 5.0\n      },\n      anglePower: {\n        type: \"f\",\n        value: 1.2\n      },\n      spotPosition: {\n        type: \"v3\",\n        value: new THREE.Vector3(0, 0, 0)\n      },\n      lightColor: {\n        type: \"c\",\n        value: new THREE.Color(\"cyan\")\n      }\n    },\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    // side\t\t: THREE.DoubleSide,\n    // blending\t: THREE.AdditiveBlending,\n    transparent: true,\n    depthWrite: false\n  });\n  return material;\n};\n\nexport default VolumetricSpotLightMaterial;\n","import React, { useEffect } from \"react\";\nimport { useThree, useFrame, extend } from \"react-three-fiber\";\n\nimport * as THREE from \"three\";\n\n// from https://github.com/jeromeetienne/threex.volumetricspotlight\nimport VolumetricSpotlight from \"../../../lib/volumetric-spotlight\";\n\nextend({\n  VolumetricSpotlight\n});\n\nexport const MyVolumetricSpotlight = React.forwardRef(function MyVolumetricSpotlight(props, ref) {\n  const vs = React.useRef();\n  const spotlight = React.useRef();\n\n  const { scene } = useThree();\n\n  const {\n    angle = 0.15,\n    penumbra = 0.6,\n    distance = 1,\n    color,\n    intensity,\n    position,\n    target\n  } = props;\n\n  // INIT\n  useEffect(() => {\n    scene.add(spotlight.current.target);\n\n    const geometry = vs.current.geometry;\n\n    geometry.applyMatrix4(\n      new THREE.Matrix4().makeTranslation(0, -geometry.parameters.height / 2, 0)\n    );\n    geometry.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI / 2));\n\n    vs.current.material.uniforms.spotPosition.value = vs.current.position;\n\n    spotlight.current.position.copy(vs.current.position);\n  }, [scene, color, position]);\n\n  useFrame(({ clock }) => {\n    spotlight.current.position.copy(vs.current.position);\n    // @todo fix this\n    vs.current.material.uniforms.lightColor.value = spotlight.current.color;\n\n\n    if (target && target.current) {\n      const targetPos = new THREE.Vector3();\n      target.current.getWorldPosition(targetPos) ;\n      vs.current.lookAt(targetPos);\n      if  (targetPos.x < 0) {\n        // vs.current.material.uniforms.lightColor.value = new THREE.Color(0xffe7dd);\n        // vs.current.material.uniforms.lightColor.value = new THREE.Color(0xffe7dd);\n        vs.current.material.uniforms.attenuation.value = 4;\n\n      }\n      spotlight.current.target.position.copy(targetPos);\n    }\n  });\n\n  const setRef = React.useCallback(function setRef(el) {\n    vs.current = el;\n\n    if (ref) {\n      ref.current = el;\n    }\n  }, [ref]);\n\n  // maps spotlight angle to volueme cylinder every frame\n  // it would be better to do it on a need-to basis\n  // but it doesn't play nice with react-spring\n  useFrame(() => {\n    const angle = spotlight.current.angle;\n\n    vs.current.scale.set(1 * angle, 1 * angle, 1);\n  });\n\n  return (\n    <>\n      <spotLight\n        ref={spotlight}\n        intensity={intensity}\n        angle={angle}\n        penumbra={penumbra}\n        distance={distance}\n        color={color}\n      />\n\n      <mesh ref={setRef} position={position}>\n        <cylinderGeometry args={[0.2, 15, 64, 30, 40, true]} attach=\"geometry\" />\n\n        <volumetricSpotlight\n          attach=\"material\"\n          uniforms-lightColor-value={color}\n          uniforms-attenuation-value={6}\n          uniforms-anglePower-value={2}\n        />\n      </mesh>\n    </>\n  );\n});\n","\nimport startOfDay from 'date-fns/startOfDay'\nimport differenceInSeconds from 'date-fns/differenceInSeconds'\n\nexport function sphericalCoordsToCartesian (radius, inclination, azimuth) {\n  /*\n   * Inclination is in the range [0, pi], from straight up (the zenith)\n   * Azimuth is in the range [0, 2pi], from the x axis\n   * See: https://en.wikipedia.org/wiki/Spherical_coordinate_system#Cartesian_coordinates\n   */\n  const x = radius * Math.sin(inclination) * Math.cos(azimuth);\n  const z = radius * Math.sin(inclination) * Math.sin(azimuth);\n  const y = radius * Math.cos(inclination);\n  return [-x, y, z];\n}\n\nexport function latlngToSphericalCoords (lat, lng) {\n  const inclination = Math.PI * (lat > 0 ? 90 - lat : 90 + Math.abs(lat)) / 180;\n  const azimuth = 2 * Math.PI * (lng >= 0 ? lng : 360 - Math.abs(lng)) / 360; \n  return [inclination, azimuth];\n}\n\nexport function calculateAngleForTime () {\n  const secondsElapsedInDay = differenceInSeconds(\n    new Date(),\n    startOfDay(new Date()),\n  )\n\n  const dayProgress = secondsElapsedInDay / (24 * 60 * 60);\n  return dayProgress * 2 * Math.PI - (Math.PI / 4);\n}\n\nexport const citiesWhereHeadlightsOn = ['Shanghai', 'New York City', 'Berlin', 'Mexico City',  'London', 'Los Angeles', 'Mumbai', 'Sydney', 'Cairo', 'Seoul', 'Moscow', 'Buenos Aires']\n","import React, {\n  useRef,\n  useState,\n  useEffect,\n} from \"react\";\nimport { useFrame } from \"react-three-fiber\";\n\nimport { MyVolumetricSpotlight } from \"./VolumetricSpotlight\";\nimport { citiesWhereHeadlightsOn } from '../../../lib';\n\n\nexport function Light ({ position, name }) {\n  const mesh = useRef();\n  const spotlightTarget = useRef();\n  const time = useRef(0);\n\n\n  // const [isHovered, setIsHovered] = useState(false);\n  const [isActive] = useState(false);\n\n  const isActiveRef = useRef(isActive);\n\n\n  // random time mod factor\n  // const timeMod = useMemo(() => random(0.1, 4, true), []);\n\n  // color\n  // const color = isHovered ? 0xefefef : (isActive ? 0xffffff : 0xeeeeee);\n\n  //useEffect of the activeState\n  useEffect(() => {\n    isActiveRef.current = isActive;\n  }, [isActive]);\n\n  // raf loop\n  useFrame(() => {\n    if (!mesh.current) return;\n    mesh.current.lookAt(0, 0, 0)\n    if (isActiveRef.current) {\n      time.current += 0.03;\n      mesh.current.position.y = position[1] + Math.sin(time.current) * 0.05;\n    }\n  });\n\n  // Events\n  // const onHover = useCallback(\n  //   (e, value) => {\n  //     e.stopPropagation();\n  //     setIsHovered(value);\n  //   },\n  //   [setIsHovered]\n  // );\n\n  // const onClick = useCallback(\n  //   e => {\n  //     e.stopPropagation();\n  //     setIsActive(v => !v);\n  //   },\n  //   [setIsActive]\n  // );\n\n  // function LightPlaceholder () {\n  //   return (\n  //     <mesh\n  //       ref={mesh}\n  //       position={position}\n  //       onClick={e => onClick(e)}\n  //       onPointerOver={e => onHover(e, true)}\n  //       onPointerOut={e => onHover(e, false)}\n  //     >\n  //       <boxBufferGeometry attach=\"geometry\" args={[0.12, 0.07, 0.05]} />\n  //       <meshStandardMaterial\n  //         attach=\"material\"\n  //         color={color}\n  //         transparent\n  //         opacity={0.8}\n  //       />\n  //     </mesh>\n  //   )\n  // }\n\n\n  return (\n    <group>\n      {\n        citiesWhereHeadlightsOn.includes(name)  && (\n          <>\n            <mesh\n              ref={spotlightTarget}\n              position={[position[0] * 10, position[1] * 10, position[2] * 10]}\n            >\n            </mesh>\n            <MyVolumetricSpotlight\n              position={[position[0] * 0.98, position[1] * 0.98, position[2] * 0.98]}\n              color={0xccccff}\n              target={spotlightTarget}\n              intensity={0.1}\n            />\n          </>\n        )\n      }\n      {/* <LightPlaceholder /> */}\n    </group>\n  );\n};\n","import React, { useEffect, useRef } from \"react\";\nimport { useFrame } from \"react-three-fiber\";\nimport { Html } from \"drei\";\nimport { CubeTexture } from \"three\";\n\nconst corsProxy = 'http://cors-anywhere.services.computerlab.io:8080';\n\nexport function WebcamImageManager ({ src, handleUpdateCubeMap }) {\n  const imgRef = useRef();\n\n  useFrame(() => {\n    const newSrc = `${corsProxy}/${src}&rand=${Math.floor(new Date().getTime() / 1000)}`\n    if (newSrc !== imgRef.current.src) imgRef.current.src = newSrc\n  })\n\n  useEffect(() => {\n    imgRef.current.onload = () => {\n      const inputWidth = imgRef.current.naturalWidth;\n      const inputHeight = imgRef.current.naturalHeight;\n\n      // const dy = inputHeight / 3;\n      // const dx = Math.floor(inputWidth / 3);\n\n      // get the aspect ratio of the input image\n      const inputImageAspectRatio = inputWidth / inputHeight;\n      const outputImageAspectRatio = 1;\n\n      // if it's bigger than our target aspect ratio\n      let outputWidth = inputWidth;\n      let outputHeight = inputHeight;\n      if (inputImageAspectRatio > outputImageAspectRatio) {\n        outputWidth = inputHeight * outputImageAspectRatio;\n      } else if (inputImageAspectRatio < outputImageAspectRatio) {\n        outputHeight = inputWidth / outputImageAspectRatio;\n      }\n\n      const outputImage = document.createElement('canvas');\n\n      // let ctx\n      // const emptySmallImage = document.createElement('canvas');\n      // emptySmallImage.width = dx;\n      // emptySmallImage.height = dx;\n      // // create a canvas that will present the output image\n      // const px = document.createElement('canvas');\n      // px.width = dx;\n      // px.height = dx;\n      // ctx = px.getContext('2d')\n      // ctx.drawImage(imgRef.current, 2 * dx, 0, dx, dx, 0, 0, dx, dx);\n      // const nx = document.createElement('canvas');\n      // nx.width = dx;\n      // nx.height = dx;\n      // ctx = nx.getContext('2d')\n      // ctx.drawImage(imgRef.current, 0, 0, dx, dx, 0, 0, dx, dx);\n      // const pz = document.createElement('canvas');\n      // pz.width = dx;\n      // pz.height = dx;\n      // ctx = pz.getContext('2d')\n      // ctx.drawImage(imgRef.current, dx, 0, dx, dx, 0, 0, dx, dx);\n      // const py = document.createElement('canvas');\n      // py.width = dx;\n      // py.height = dx;\n      // ctx = py.getContext('2d')\n      // ctx.drawImage(imgRef.current, dx, 0, dx, dx, 0, 0, dx, dx);\n      // const ny = document.createElement('canvas');\n      // ny.width = dx;\n      // ny.height = dx;\n      // ctx = ny.getContext('2d')\n      // ctx.drawImage(imgRef.current, dx, 2 * dx, dx, dx, 0, 0, dx, dx);\n\n\n      // const emptyImage = document.createElement('canvas');\n\n      // set it to the same size as the image\n      outputImage.width = outputWidth;\n      outputImage.height = outputHeight;\n      // emptyImage.width = outputWidth;\n      // emptyImage.height = outputHeight;\n\n      // draw our image at position 0, 0 on the canvas\n      let ctx = outputImage.getContext('2d');\n      ctx.drawImage(imgRef.current, 0, 0);\n\n      // show both the image and the canvas\n\n      // const map = new CubeTexture(\n      //   [px, nx, emptySmallImage, emptySmallImage, pz, pz ]\n      // )\n\n      const map = new CubeTexture(\n        [outputImage, outputImage, outputImage, outputImage, outputImage, outputImage ]\n      )\n      map.needsUpdate = true;\n      handleUpdateCubeMap(map)\n    }\n  }, [handleUpdateCubeMap])\n\n\n  return (\n    <Html>\n      <img alt='nyc traffic cam' style={{ display: 'none' }} crossOrigin=\"anonymous\" ref={imgRef} src={`${corsProxy}/${src}`} />\n    </Html>\n  )\n}\n","import React, { useEffect, useRef, createRef } from 'react'\nimport { useLoader } from \"react-three-fiber\";\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\nimport { draco } from \"drei\";\nimport { BackSide } from \"three\";\nimport { WebcamImageManager } from \"../../WebcamImageManager\";\nimport { citiesWhereHeadlightsOn } from \"../../../lib\";\n\nconst hkSrc = 'https://tdcctv.data.one.gov.hk/K107F.JPG?';\nconst nycSrc = 'http://207.251.86.238/cctv884.jpg?'\n\nexport function EightSeriesHeadlightManager ({ locations }) {\n  const [nycCubeMap, setNycCubeMap] = React.useState(null)\n  const [hkCubeMap, setHkCubeMap] = React.useState(null)\n\n  const { nodes } = useLoader(\n    GLTFLoader,\n    process.env.PUBLIC_URL + \"/headlight-simpler-origin.glb\",\n    draco(process.env.PUBLIC_URL + \"/draco-gltf/\")\n  );\n\n  const refs = useRef(locations.map(() => createRef()))\n  useEffect(() => {\n\n\n    for (const r of refs.current) {\n      r.current.lookAt(0,0,0)\n      // r.current.rotateX(Math.PI / 2)\n      r.current.rotateY( 5 * Math.PI / 4)\n      // r.current.rotateZ(Math.PI / 4)\n    }\n  }, [])\n\n  const meshObjects = locations.map(({ position, name }, i) => {\n    const envMap = {\n      \"New York City\": nycCubeMap,\n      \"Hong Kong\": hkCubeMap,\n      \"Qingdao\": hkCubeMap,\n\n    }\n    return (\n      <group scale={[0.012, 0.012, 0.012 ]} key={name} position={position} ref={refs.current[i]}>\n        <mesh visible geometry={nodes['visor'].geometry}>\n          <meshPhysicalMaterial\n            attach=\"material\"\n            color={0xeeeeee}\n            roughness={0.05}\n            envMap={envMap[name]}\n            envMapIntensity={1.5}\n            clearcoat={0.9}\n            metalness={0.9}\n            opacity={1}\n            transmission={0.6}\n            transparent\n            depthWrite={false}\n          />\n        </mesh>\n        <mesh visible geometry={nodes['headlight-simpler'].geometry}>\n          <meshPhysicalMaterial\n            attach=\"material\"\n            color={0x778899}\n            roughness={0.3}\n            metalness={0.7}\n            clearcoat={0.7}\n          />\n        </mesh>\n        <mesh visible geometry={nodes['griddy-thing'].geometry}>\n          <meshPhysicalMaterial\n            attach=\"material\"\n            color={0xddeeff}\n            roughness={0.2}\n            metalness={0.8}\n            emissive={citiesWhereHeadlightsOn.includes(name) ? 0xaaaaff : null}\n            opacity={1}\n            transparent\n            transmission={0.94}\n            depthWrite={false}\n          />\n        </mesh>\n        <mesh visible geometry={nodes['griddy-thing'].geometry}>\n          <meshPhysicalMaterial\n            attach=\"material\"\n            color={0xddeeff}\n            roughness={0.2}\n            metalness={0.8}\n            emissive={citiesWhereHeadlightsOn.includes(name) ? 0xaaaaff : null}\n            opacity={1}\n            transparent\n            transmission={0.4}\n            depthWrite={false}\n            side={BackSide}\n          />\n        </mesh>\n        {citiesWhereHeadlightsOn.includes(name) && (\n          <mesh position={[-5.5, 0, -1]}>\n            {/* <sphereBufferGeometry attach=\"geometry\" args={[1, 32, 32]} /> */}\n            {/* <meshBasicMaterial attach=\"material\" color=\"#FFFF99\" fog={false} /> */}\n            <pointLight\n              args={[0x7777ff, 8, 0.1]}\n            />\n          </mesh>\n        )\n        }\n        {citiesWhereHeadlightsOn.includes(name) && (\n          <mesh position={[-1, 1, 5]}>\n            {/* <sphereBufferGeometry attach=\"geometry\" args={[1, 32, 32]} /> */}\n            {/* <meshBasicMaterial attach=\"material\" color=\"#FFFF99\" fog={false} /> */}\n            <pointLight\n              args={[0x7777ff, 8, 0.1]}\n            />\n          </mesh>\n        )\n        }\n        <mesh visible geometry={nodes['bulbs'].geometry}>\n          <meshStandardMaterial\n            attach=\"material\"\n            color={0xaaaaff}\n            roughness={0.3}\n            metalness={0.5}\n            emissive={citiesWhereHeadlightsOn.includes(name) ? 0xaaaaff : null}\n          />\n        </mesh>\n        <mesh visible geometry={nodes['top-light'].geometry}>\n          <meshPhysicalMaterial\n            attach=\"material\"\n            color={0xddffff}\n            roughness={0.1}\n            metalness={0.8}\n            emissive={citiesWhereHeadlightsOn.includes(name) ? 0xaaaaff : null}\n            opacity={1}\n            transparent\n            transmission={0.5}\n            depthWrite={false}\n          />\n        </mesh>\n        <mesh visible geometry={nodes['complex--inner-thing-1'].geometry}>\n          <meshStandardMaterial\n            attach=\"material\"\n            color={0x3333ff}\n            roughness={0.6}\n            metalness={0.5}\n          />\n        </mesh>\n        <mesh visible geometry={nodes['complex-inner-thing-2'].geometry}>\n          <meshStandardMaterial\n            attach=\"material\"\n            color={0x3333ff}\n            roughness={0.3}\n            metalness={0.5}\n          />\n        </mesh>\n      </group>\n    )})\n  return (\n    <group>\n      <WebcamImageManager src={nycSrc} handleUpdateCubeMap={setNycCubeMap} />\n      <WebcamImageManager src={hkSrc} handleUpdateCubeMap={setHkCubeMap} />\n      {meshObjects}\n    </group>\n  )\n}\n","import React, { useRef } from \"react\";\nimport { useFrame } from \"react-three-fiber\";\n\nimport { Light } from \"./Light/Light\";\nimport { sphericalCoordsToCartesian, latlngToSphericalCoords, calculateAngleForTime } from \"../../lib\";\nimport cities from \"../../lib/cities.json\";\n\nimport { EightSeriesHeadlightManager } from \"./Light/EightSeriesHeadlightManager\";\n\nexport function LightGlobe () {\n  const group = useRef();\n\n  useFrame(() => {\n    group.current.rotation.y = calculateAngleForTime()\n    // group.current.rotation.y += 0.0005;\n    // use redux here instead\n  });\n\n  const RADIUS = 3;\n  const locations = cities.map(({ lat, lng, name }) => {\n    const [inc, azm ] = latlngToSphericalCoords(lat, lng)\n    return {\n      position: sphericalCoordsToCartesian(RADIUS, inc, azm),\n      name,\n    }\n  })\n\n  const lights = cities.map(({ lat, lng, name }) => {\n    const coords = latlngToSphericalCoords(lat, lng);\n    const [inc, azm] = coords\n    return (\n      <Light\n        key={`${inc}-${azm}`}\n        position={sphericalCoordsToCartesian(RADIUS, inc, azm)}\n        spotlightTargetPosition={sphericalCoordsToCartesian(RADIUS * 1.2, inc, azm)}\n        name={name}\n      />\n    )\n\n  })\n\n\n  return (\n    <group ref={group}>\n      {lights}\n      <EightSeriesHeadlightManager locations={locations} />\n    </group>\n  )\n  ;\n};\n","import \"./styles.css\";\n\nimport React, { Suspense } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Credits from \"./components/Credits\";\nimport { Canvas } from \"react-three-fiber\";\nimport Lights from \"./components/Lights\";\nimport { LightGlobe } from \"./components/LightGlobe/LightGlobe\";\nimport { OrbitControls, Stars, Html } from \"drei\";\n\nconst loader = (\n  <Html center>\n    <div className='loading'>\n      <h1 style={{color: 'white'}}>TODAY IS NOTHING LIKE TOMORROW IS NOTHING LIKE TODAY</h1>\n      <h3 style={{color: 'white'}}>LOADING...</h3>\n    </div>\n  </Html>\n)\n\nfunction App() {\n  return (\n    <>\n      <Credits/>\n      <Canvas colorManagement shadowMap style={{ background: '#020204' }}>\n        <fog attach=\"fog\" args={[\"#020204\", 1, 15]} />\n        <Lights />\n        <Suspense fallback={loader}>\n          <LightGlobe />\n        </Suspense>\n        <OrbitControls enablePan={false} zoomSpeed={0.5} />\n        <Stars factor={2} saturation={0.7} />\n      </Canvas>\n    </>\n  );\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}